# go 并发机制
Go语言的并发模型是CSP（Communicating Sequential Processes）模型，它是一种基于消息传递的并发模型，通过channel来实现不同goroutine之间的通信和同步。goroutine 是一种轻量级线程，可以在一个程序中同时运行成千上万个goroutine，而不会导致系统资源的枯竭。channel 是一种通信机制，可以让不同的 goroutine 之间进行通信和同步。  
go底层选择使用coroutine的出发点是因为，它具有以下特点：
* 用户空间 避免了内核态和用户态的切换导致的成本。
* 可以由语言和框架层进行调度。
* 更小的栈空间允许创建大量的实例。

# 进程、线程、协程有什么区别？
  * 进程：进程是资源分配的最小单位，是应用程序的启动实例，每个进程都有独立的内存空间，不同的进程通过进程间的通信方式来通信。
  * 线程：线程是 CPU 调度的基本单位，从属于进程，每个进程至少包含一个线程，多个线程之间可以共享进程的资源并通过共享内存等线程间的通信方式来通信。
  * 协程：为轻量级线程，与线程相比，协程不受操作系统的调度，协程的调度器由用户应用程序提供，协程调度器按照调度策略把协程调度到线程中运行  

### **进程**
在程序启动时，操作系统会给该程序分配一块内存空间，对于程序但看到的是一整块连续的内存空间，称为虚拟内存空间，落实到操作系统内核则是一块一块的内存碎片的东西。为的是节省内核空间，方便对内存管理。
![img](https://pic4.zhimg.com/80/v2-dd59995cec820561819ace49882d6263_720w.webp)

就这片内存空间，又划分为用户空间与内核空间，用户空间只用于用户程序的执行，若要执行各种IO操作，就会通过系统调用等进入内核空间进行操作。

### **线程**
线程是进程的一个执行单元，一个进程可以包含多个线程，只有拥有了线程的进程才会被CPU执行，所以一个进程最少拥有一个主线程。  
![img](https://pic4.zhimg.com/80/v2-1c3fcd78cea7a63572e6f103a5fc64ab_720w.webp)  
由于多个线程可以共享同一个进程的内存空间，线程的创建不需要额外的虚拟内存空间，线程之间的切换也就少了如进程切换的切换页表，切换虚拟地址空间此类的巨大开销。至于进程切换为什么较大，简单理解是因为进程切换要保存的现场太多如寄存器，栈，代码段，执行位置等，而线程切换只需要上下文切换，保存线程执行的上下文即可。线程的的切换只需要保存线程的执行现场(程序计数器等状态)保存在该线程的栈里，CPU把栈指针，指令寄存器的值指向下一个线程。相比之下线程更加轻量级。  

可以说进程面向的主要内容是内存分配管理，而线程主要面向的CPU调度。

### **协程**
虽然线程比进程要轻量级，但是每个线程依然占有1M左右的空间，在高并发场景下非常吃机器内存  
而且线程切换的开销也是不可忽视的。同时，线程的创建与销毁同样是比较大的系统开销（可以通过线程池或协程来解决）  
**协程是用户态的线程**，比线程更加的轻量级，操作系统对其没有感知，之所以没有感知是由于协程处于线程的用户栈能感知的范围，是由用户创建的而非操作系统。  
![img](https://pic2.zhimg.com/80/v2-074473303f2803fa99f97482f34aba19_720w.webp)  
如一个进程可拥有以有多个线程一样，一个线程也可以拥有多个协程。协程之于线程如同线程之于cpu，拥有自己的协程队列，每个协程拥有自己的栈空间，在协程切换时候只需要保存协程的上下文，开销要比内核态的线程切换要小很多。


# CSP 与 GMP
* Golang的并发机制是基于CSP模型的，
* 而GMP模型是Go语言中的一种调度模型

# GMP
https://zhuanlan.zhihu.com/p/261057034  
https://zhuanlan.zhihu.com/p/288017699  

* 什么是 GMP？
  * **含义**：G 代表着 goroutine(初始化的栈空间大约2k大小)，P 代表着上下文处理器（调度器），M 代表 thread 线程
  * 在 GPM 模型，有一个**全局队列**（Global Queue）：存放等待运行的 G，还有一个 P 的**本地队列**：也是存放等待运行的 G，但数量有限，不超过 256 个。  
  * **P 列表**：所有的 P 都在程序启动时创建，并保存在数组中，最多有 GOMAXPROCS(可配置) 个。
  * **M**：线程想运行任务就得获取 P，从 P 的本地队列获取 G。P 本地队列为空时，M 也会尝试从全局队列拿一批 G 放到 P 的本地队列，或从其他 P 的本地队列偷一半放到自己 P 的本地队列。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。  
  ![img](https://pic1.zhimg.com/80/v2-a851cc7ac7d3c4c8f0d33f5634473330_720w.webp)

  * GPM 的调度流程从 go func()开始创建一个 goroutine，新建的 goroutine 优先保存在 P 的本地队列中，如果 P 的本地队列已经满了，则会保存到全局队列中。
  * 当 M 执行某一个 G 时候发生系统调用或者阻塞，M 阻塞，如果这个时候 G 在执行，runtime 会把这个线程 M 从 P 中摘除，然后创建一个新的操作系统线程来服务于这个 P，
  * 当 M 系统调用结束时，这个 G 会尝试获取一个空闲的 P 来执行，并放入到这个 P 的本地队列，如果获取不到P，这个线程 M 变成休眠状态，加入到空闲线程中，然后整个 G 就会被放入到全局队列中。
  * 关于 G,P,M 的个数问题，G 的个数理论上是无限制的，但是受内存限制，P 的数量一般建议是逻辑 CPU 数量的 2 倍，M 的数据默认启动的时候是 10000，内核很难支持这么多线程数，所以整个限制客户忽略，M 一般不做设置，设置好 P，M 一般都是要大于 P。   
![img](https://pic1.zhimg.com/80/v2-d9d8dadcdaf2d3119b5f488d9da7bf2c_720w.webp) 



# 如何实现并发控制
* 使用 channel  
可以创建一个channel，缓冲区设置为你想要的最大并发数，比如100。每创建一个协程前，就往channel里写入一个数值，表示占位。每当一个协程执行结束时，就从channel中读出一个数值，表示让位。当当前同时在执行的协程达到最大并发数时，即channel的缓冲区被占满，此时新的协程要执行时，占位会被阻塞，直到有其他协程退出让位后，才会执行
```go
func main() {
  count := 10 // 最大支持并发
  sum := 100 // 任务总数
  // sync.WaitGroup{}是Golang中的一个结构体类型，
  // 用于阻塞等待一组Go程的结束。主Go程调用Add()来设置等待的Go程数，
  // 然后该组中的每个Go程都需要在运行结束时调用Done()，
  // 递减WaitGroup的Go程计数器counter。当counter变为0时，主Go程被唤醒继续执行。
  wg := sync.WaitGroup{} //控制主协程等待所有子协程执行完之后再退出。

  c := make(chan struct{}, count) // 控制任务并发的chan
  defer close(c)

  for i:=0; i<sum;i++{
    wg.Add(1)
    c <- struct{}{} // 作用类似于waitgroup.Add(1)
    go func(j int) {
      defer wg.Done()
      fmt.Println(j)
      <- c // 执行完毕，释放资源
    }(i)
  }
  wg.Wait()
}
```

* 协程池
  * 开源项目 ants：https://github.com/panjf2000/ants


# 主协程如何等待其余协程退出?
* Go 的 sync.WaitGroup 是等待一组协程结束，sync.WaitGroup 只有 3 个方法，Add()是添加计数，Done()减去一个计数，Wait()阻塞直到所有的任务完成。Go 里面还能通过有缓冲的 channel 实现其阻塞等待一组协程结束，这个不能保证一组 goroutine 按照顺序执行，可以并发执行协程。
* Go 里面能通过无缓冲的 channel 实现其阻塞等待一组协程结束，这个能保证一组 goroutine 按照顺序执行，但是不能并发执行。

> Add()表示协程计数，可以一次Add多个，如Add(3),可以多次Add(1);然后每个子协程必须调用done（）,这样才能保证所有子协程结束，主协程才能结束。

