https://zhuanlan.zhihu.com/p/390926887  
https://blog.csdn.net/qq_35971258/article/details/120057713
#  垃圾是如何产生的？
垃圾是指程序向堆栈申请的内存空间，随着程序的运行已经不再使用这些内存空间，这时如果不释放他们就会造成垃圾也就是内存泄漏。

#  go 如何实现 GC 的？
* Go 的 GC 回收有三次演进过程：
  * Go1.3使用的是标记清除法
  * GoV1.5 三色标记法
  * Go1.8 三色标记+混合写屏障

* Go1.3 标记清除法：
  * 进行STW（stop the world, 即暂停程序业务逻辑），然后从main函数开始找到不可达的内存占用和可达的内存占用
  * 开始标记，程序找出可达内存占用并做标记
  * 标记结束清除未标记的内存占用
  * 结束STW停止暂停，让程序继续运行，循环该过程直到main生命周期结束

  Go1.3 之前的做法是将垃圾清理结束时才停止STW，后来优化了方案将清理垃圾放到了STW之后，与程序运行同时进行，这样做减小了STW的时长。但是STW会暂停用户逻辑对程序的性能影响是非常大的，这种粒度的STW对于性能较高的程序还是无法接受，因此Go1.5采用了三色标记法优化了STW。
  ![img](https://pic3.zhimg.com/80/v2-3599fde05fc60c8312d82e7984b27ce2_720w.webp)

* Go1.5 三色标记法:
  * 将所有对象标记为白色
  * 从根节点集合出发，将第一次遍历到的节点标记为灰色放入集合列表中
  * 遍历灰色集合，将灰色节点遍历到的白色节点标记为灰色，并把灰色节点标记为黑色
  * 循环这个过程
  * 直到灰色节点集合为空，回收所有的白色节点  

  这种方法看似很好，但是将GC和程序会放一起执行，会因为cpu的调度出现下面这种情况，导致被引用的对象3会被垃圾回收掉，从而出现错误: 
  * 对象2断开了对对象3的引用，而对象4新增对对象3的引用
  * 执行GC，发现对象2和对象5到达不了对象3
  * 此时会发生将对象3回收的错误  
![img](https://pic1.zhimg.com/80/v2-d695718ace0d8f5db7642d96684f6174_720w.webp)

  分析bug的根源所在，主要是因为程序在运行过程中出现了下面俩种情况
  * 一个白色对象被黑色对象引用
  * 灰色对象与它之间的可达关系的白色对象遭到破坏  

  因此在此基础上拓展出了俩种方法，强三色不变式和弱三色不变式：
    * 强三色不变式：不允许黑色对象引用白色对象
    * 弱三色不变式：黑色节点可以引用白色节点，但是白色节点必须存在其他的灰色节点对他的引用(不能删除灰色节点对白色节点的引用)，或者可达它的链路上有存在灰色节点  

  为了实现这俩种不变式的设计思想，从而引出了屏障机制，值得注意的是为了保证栈的运行效率，屏障只对堆上的内存对象启用，栈上的内存会在GC结束后启用STW重新扫描。：
  * 插入屏障：实现的是强三色不变式。对象被引用时触发的机制，当白色对象被黑色对象引用时，白色对象被标记为灰色。缺点在于：如果对象1在栈上新创建了一个对象6，由于栈没有屏障机制，所以对象6仍为白色节点会被回收，所以栈在GC迭代结束时（没有灰色节点），会对栈执行STW，重新进行扫描清除白色节点。  
  * 删除屏障：则实现了弱三色不变式。对象被删除时触发的机制。如果灰色对象引用的白色对象被删除时，那么白色对象会被标记为灰色。缺点：这种做法回收精度较低，一个对象即使被删除仍可以活过这一轮再下一轮被回收。（如果对象4没有引用对象3，此时对象3应该作为垃圾被回收，但是对象3却要等到下一轮GC才会被回收）

* Go1.8 三色标记+混合写屏障  
由于插入写屏障和删除写屏障在结束时需要STW来重新扫描栈所带来的性能瓶颈，Go在1.8引入了混合写屏障的方式实现了弱三色不变式的设计方式，混合写屏障分下面四步：
  * GC开始时将栈上可达对象全部标记为黑色（不需要二次扫描，无需STW）
  * GC期间，任何栈上创建的新对象均为黑色
  * 被删除引用的对象标记为灰色
  * 被添加引用的对象标记为灰色
![img](https://pic3.zhimg.com/80/v2-750e44773b0530fe7446171f90581de2_720w.webp)


# 3. GC 触发条件？
  * 自动触发
    * 一是堆内存的分配达到控制器计算的触发堆大小，初始大小环境变量GOGC，之后堆内存达到上一次垃圾收集的 2 倍时才会触发GC。
    * 二是如果一定时间内没有触发，就会触发新的循环，该触发条件由runtime.forcegcperiod变量控制，默认为 2 分钟。
  * 手动触发：开发者在业务代码中自行调用 runtime.GC 方法来触发 GC 行为。

# GC 的代码实现？

# GC 中 stw 时机，各个阶段是如何解决的？

# 什么情况下内存会泄露？
* goroutine泄漏：在Golang中，内存泄漏一般是由于goroutine泄漏导致的，即goroutine没有被关闭或没有添加超时控制，让goroutine一直处于阻塞状态，不能被GC。
* 互斥锁未释放或者造成死锁会造成内存泄漏
* time.Ticker 是每隔指定的时间就会向通道内写数据，必须调用 stop 方法才会停止，否则会一直占用内存空间。
* 字符串的截取引发临时性的内存泄漏
* 切片截取引起子切片内存泄漏

# 怎么定位排查内存泄漏问题？
https://zhuanlan.zhihu.com/p/368567370  
https://www.cnblogs.com/ricklz/p/11262069.html  
使用 pprof 工具。集成 pprof 非常简单，只需要在工程中引入如下代码即可：
```go
import _ "net/http/pprof"

go func() {
 log.Println(http.ListenAndServe("localhost:6060", nil))
}()
```
之后可以通过以下方式进行查看：
* 浏览器查看：访问 http://127.0.0.1:6069/debug/pprof/
* 命令行模式分析：使用命令go tool pprof url就可以获取指定的profile文件，下载到本地，使用命令行进行分析

# golang 的内存逃逸
内存逃逸 ：Go中程序变量会携带一组校验数据，用来证明它的整个生命周期在程序运行时是否完全可知。如果变量通过了这些校验，它就可以在栈上分配，反之就可以说它逃逸了，这时就必须在堆上分配。  
内存逃逸有以下几种情况：
* 指针逃逸：在方法内把局部变量指针返回时，会出现内存逃逸。因为局部变量原本应该在栈上分配，并且在栈中回收，但是由于在返回时被外部引用，因此该变量的生命周期大于栈，这时就会发生内存溢出。
* 栈空间不足逃逸：当栈空间不足时会分配到堆上。
* 发送指针或是带有指针的值到channel中：因为在代码编译的时候，是没有办法知道是哪个goroutine会在channel上接收数据，所以编译器没办法知道变量什么时候才会被释放。
* 切片中存储指针或是带有指针的值：因为尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。
* slice扩容可能导致内存逃逸：如果在程序运行时扩容，就会在堆上分配
* interface类型：因为interface类型可以代表任意类型，编译器不知道参数会是什么类型，只有运行时才知道，因此只能分配到堆上。

# go 是如何分配内存的？
https://blog.csdn.net/kevin_tech/article/details/121391666  
https://zhuanlan.zhihu.com/p/352133292  
Go 分配内存的过程，主要由三大组件所管理，级别从上到下分别是：

* mheap  
Go 在程序启动时，首先会向操作系统申请一大块内存，并交由mheap结构全局管理。具体怎么管理呢？  
mheap 会将这一大块内存，切分成不同规格的小内存块，我们称之为 mspan，根据规格大小不同，mspan 大概有 70类左右，划分得可谓是非常的精细，足以满足各种对象内存的分配。  
那么这些 mspan 大大小小的规格，杂乱在一起，肯定很难管理对吧？  
因此就有了 mcentral 这下一级组件

* mcentral  
启动一个 Go 程序，会初始化很多的 mcentral ，每个 mcentral 只负责管理一种特定规格的 mspan。
相当于 mcentral 实现了在 mheap 的基础上对 mspan 的精细化管理。  
但是 mcentral 在 Go 程序中是全局可见的，因此如果每次协程来 mcentral 申请内存的时候，都需要加锁。可以预想，如果每个协程都来 mcentral 申请内存，那频繁的加锁释放锁开销是非常大的。  
因此需要有一个 mcentral 的二级代理来缓冲这种压力

* mcache  
在一个 Go 程序里，每个线程M会绑定给一个处理器P，在单一粒度的时间里只能做多处理运行一个goroutine，每个P都会绑定一个叫 mcache 的本地缓存。  
当需要进行内存分配时，当前运行的goroutine会从mcache中查找可用的mspan。从本地mcache里分配内存时不需要加锁，这种分配策略效率更高。

还有一条供应链：
* mspan 供应链  
mcache 的 mspan 数量并不总是充足的，当供不应求的时候，mcache 会从 mcentral 再次申请更多的 mspan，同样的，如果 mcentral 的 mspan 数量也不够的话，mcentral 也会向它的上级 mheap 申请 mspan。再极端一点，如果 mheap 里的 mspan 也无法满足程序的内存申请，那该怎么办？那就没办法啦，mheap 只能厚着脸皮跟操作系统这个老大哥申请了。
![img](https://img-blog.csdnimg.cn/img_convert/70777b611680980e28983c42fbf5d924.png)
以上的供应流程，**只适用于分配小内存的场景**，原因在于Go 没法使用工作线程的本地缓存mcache和全局中心缓存 mcentral 上管理超过 64KB 的内存分配，所以对于那些**大内存的内存申请，会直接从堆上(mheap)上分配对应的数量的内存页（每页大小是 8KB）给程序。**

# 什么是堆内存和栈内存？
根据内存管理（分配和回收）方式的不同，可以将内存分为 堆内存 和 栈内存。

* 堆内存：由内存分配器和垃圾收集器负责回收

* 栈内存：由编译器自动进行分配和释放

一个程序运行过程中，也许会有多个栈内存，但肯定只会有一个堆内存。

每个栈内存都是由线程或者协程独立占有，因此从栈中分配内存不需要加锁，并且栈内存在函数结束后会自动回收，性能相对堆内存好要高。

而堆内存呢？由于多个线程或者协程都有可能同时从堆中申请内存，因此在堆中申请内存需要加锁，避免造成冲突，并且堆内存在函数结束后，需要 GC （垃圾回收）的介入参与，如果有大量的 GC 操作，将会吏程序性能下降得历害。



# 介绍一下大对象小对象，为什么小对象多了会造成 gc 压力？
小于等于 32k 的对象就是小对象，其它都是大对象。一般小对象通过 mspan 分配内存；大对象则直接由 mheap 分配内存。通常小对象过多会导致 GC 三色法消耗过多的 CPU。优化思路是，减少对象分配。

小对象：如果申请小对象时，发现当前内存空间不存在空闲跨度时，将会需要调用 nextFree 方法获取新的可用的对象，可能会触发 GC 行为。

大对象：如果申请大于 32k 以上的大对象时，可能会触发 GC 行为。