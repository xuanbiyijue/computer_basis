# 网络层模型
![img](https://pic1.zhimg.com/80/v2-99dde495a98423eb364a74262fb4a974_720w.webp)

# 在浏览器中输入URL后，执行的全部过程  
https://zhuanlan.zhihu.com/p/57895541    
一次完整的HTTP请求过程：  
1. **首先进行域名解析**，域名解析具体过程讲一下：  
  * 浏览器搜索自己的DNS缓存，缓存中维护一张域名与IP地址的对应表；
    * 若没有，则搜索操作系统的DNS缓存；
    * 若还是没有，则操作系统将域名发送至本地域名服务器（递归查询方式），本地域名服务器查询自己的DNS缓存，查找成功则返回结果，否则，通过以下方式迭代查找：
      * 本地域名服务器向根域名服务器发起请求，根域名服务器返回com域的顶级域名服务器的地址；
      * 本地域名服务器向com域的顶级域名服务器发起请求，返回权限域名服务器地址；
      * 本地域名服务器向权限域名服务器发起请求，得到IP地址；
  * 本地域名服务器将得到的IP地址返回给操作系统，同时自己将IP地址缓存起来；操作系统将IP地址返回给浏览器，同时自己也将IP地址缓存起来；  
  至此，浏览器已经得到了域名对应的IP地址。

2. **浏览器发起HTTP请求**，HTTP 请求分为三个部分：***TCP 三次握手、http 请求响应信息、关闭 TCP 连接***：  
* TCP 三次握手：在客户端发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息。
  * 客户端发送一个带 SYN=1，Seq=X 的数据包到服务器端口（第一次握手，由浏览器发起，告诉服务器我要发送请求了）
  * 服务器发回一个带 SYN=1， ACK=X+1， Seq=Y 的响应包以示传达确认信息（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）
  * 客户端再回传一个带 ACK=Y+1， Seq=Z 的数据包，代表“握手结束”（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧） 

  （三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。） 

  ![img](https://pic1.zhimg.com/80/v2-31f1cee61df551bbb0f81b4b9688f5d4_720w.webp)

  > 为什么不使用两次握手  
  > ![img](https://img-blog.csdnimg.cn/888598352d2342c58e3c8387abb492e4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ29kZXIgWHU=,size_20,color_FFFFFF,t_70,g_se,x_16)

* http 请求响应信息  
  * 发送 HTTP 请求  
  TCP 三次握手结束后，开始发送 HTTP 请求报文。请求报文由请求行（request line）、请求头（header）、请求体三个部分组成  
  ![img](https://pic4.zhimg.com/80/v2-0004258bd5cd7513f175c093a69b8777_720w.webp)

    ---
    .  
    .  
    ... 中间经历若干层 ...  
    .  
     
    ---

  * 服务器处理请求并返回 HTTP 报文  
  响应报文由响应行（request line）、响应头部（header）、响应主体三个部分组成。  

* 关闭 TCP 连接  
这部分放后面说

3. 浏览器解析渲染页面  
    浏览器解析渲染页面分为一下五个步骤：
    * 根据 HTML 解析出 DOM 树
    * 根据 CSS 解析生成 CSS 规则树
    * 结合 DOM 树和 CSS 规则树，生成渲染树
    * 根据渲染树计算每一个节点的信息
    * 根据计算好的信息绘制页面

4. 关闭 TCP 连接  
当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手。  
    * 发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)
    * 被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)
    * 被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)
    * 发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)
![img](https://pic4.zhimg.com/80/v2-341a990377d3a445c14ebd961269b3d3_720w.webp)


生成HTTP请求报文后，报文会经过传输层、网络层、数据链路层和物理层，最终到达服务器。

1. 在传输层，HTTP请求报文会被封装在TCP数据包中。TCP协议负责将数据包从源主机发送到目的主机，并确保数据包能够正确无误地到达目的主机。
2. 在网络层，通过IP协议, TCP数据包会被封装在IP数据包中。然后此时会用到ARP协议，主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址，找到目的MAC地址；
3. 在数据链路层，IP数据包会被添加首部和尾部，封装为MAC帧。以太网协议负责实现网络相邻节点间可靠的数据通信。
4. 在物理层，以太网帧会被转换为电信号或光信号，在物理介质中传输。  

# DNS的工作原理  
* 浏览器搜索自己的DNS缓存，缓存中维护一张域名与IP地址的对应表；
    * 若没有，则搜索操作系统的DNS缓存；
    * 若还是没有，则操作系统将域名发送至本地域名服务器（递归查询方式），本地域名服务器(LDNS，一般在你的城市的某个角落，这台服务器的性能很好，大约80%的域名解析到这里就完成了)查询自己的DNS缓存，查找成功则返回结果，否则，通过以下方式迭代查找：
      * 本地域名服务器向根域名服务器发起请求，根域名服务器返回com域的顶级域名服务器的地址；
      * 本地域名服务器向com域的顶级域名服务器发起请求，返回权限域名服务器地址；
      * 本地域名服务器向权限域名服务器发起请求，得到IP地址；
* 本地域名服务器将得到的IP地址返回给操作系统，同时自己将IP地址缓存起来；操作系统将IP地址返回给浏览器，同时自己也将IP地址缓存起来；  

DNS解析过程类似一颗树，主机向本地域名服务器一般是递归查询； 向根用域名服务器查询是迭代查询。
* 递归查询：本地域名服务器就以DNS客户的身份，向其他根域名服务器继续发出查询请求报文（即替该主机继续查询），而不是让该主机自己进行下一步的查询。
* 迭代查询：根域名服务器收到请求报文时，要么给出所要查询的IP地址，要么告诉本地域名服务器，“你下一步应当向哪一个域名服务器进行查询”。  

DNS域名系统，将域名转换为IP地址，属于应用层协议，并且基于传输层的UDP协议。为什么采用UDP协议：
* UDP协议是一种无连接的、不可靠的、基于数据报的传输层通信协议。它提供了一种简单的、低开销的数据传输方式，适用于对实时性要求较高、对可靠性要求不高的应用场景。  

# HTTP
HTTP全称是Hyper Text Transfer Protocol. 即超文本传输协议，它是以TCP/IP为基础来传输HTML，文件图片等。  
HTTP是无状态协议：HTTP本身并不保存用户的任何信息，也不会对传输的数据，状态信息进行持久化；  
HTTP是无连接协议：每次连接只处理一个请求，服务器处理完用户请求，即断开连接，借此节约传输时间。  

* HTTP 通信过程
  1. 用户输入网址, DNS服务器进行域名解析
  2. 进行TCP三次握手, 建立TCP连接
  3. 发送HTTP请求
  4. 服务器接受请求并返回HTTP响应
  5. 释放连接TCP连接：若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;
  6. 客户端浏览器解析HTML内容：客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。  

* HTTP 请求次数  
HTTP请求的次数取决于具体的情况。当用户在浏览器中输入URL并点击回车后，浏览器会发送一个HTTP请求到服务器。服务器处理请求并返回HTTP响应，浏览器接收HTTP响应并渲染页面。  

  如果服务器返回的响应中包含了其他资源的引用，如图片、CSS样式表、JavaScript脚本等，浏览器会再次发送HTTP请求来获取这些资源。例如，如果响应中包含了一个<img>标签，浏览器会发送一个HTTP请求来获取图片；如果响应中包含了一个<link>标签，浏览器会发送一个HTTP请求来获取CSS样式表；如果响应中包含了一个\<script>标签，浏览器会发送一个HTTP请求来获取JavaScript脚本。

  因此，**一次搜索过程中可能会发送多个HTTP请求**。每个HTTP请求都遵循相同的流程：浏览器生成HTTP请求报文并通过TCP连接发送到服务器，服务器处理请求并返回HTTP响应，浏览器接收HTTP响应并渲染页面。

* HTTP缓存  
http缓存指的是: 当客户端向服务器请求资源时，会先抵达浏览器缓存，如果浏览器有“要请求资源”的副本，就可以直接从浏览器缓存中提取而不是从原始服务器中提取这个资源。  常见的http缓存只能缓存get请求响应的资源。  

  HTTP 缓存又分为强缓存和协商缓存：
  * 强制缓存: 在缓存数据未失效的情况下（即Cache-Control的max-age没有过期或者Expires的缓存时间没有过期），那么就会直接使用浏览器的缓存数据，不会再向服务器发送任何请求。
  * 协商缓存：当第一次请求时服务器返回的响应头中没有Cache-Control和Expires、Cache-Control和Expires过期、它的属性设置为no-cache时(即不走强缓存)，那么浏览器第二次请求时就会与服务器进行协商，与服务器端对比判断资源是否进行了修改更新。  

* HTTP 常用状态码
  * 1xx：目前是协议的中间状态，还需要后续请求。  
  101 切换请求协议，从 HTTP 切换到 WebSocket  

  * 2xx：表示请求成功。  
  200 请求成功，有响应体

  * 3xx：表示重定向状态，需要重新请求。  
  301 永久重定向：会缓存；
  302 临时重定向：不会缓存；
  304 协商缓存命中

  * 4xx：请求报文错误。  
  403 服务器禁止访问；
  404 资源未找到；
  400 请求错误

  * 5xx：服务器错误。  
  500 服务器端错误；
  503 服务器繁忙  

* HTTP 请求报文和响应  
  * 请求报文，由请求行（request line）、请求头（header）、请求体三个部分组成    
  ![img](https://pic4.zhimg.com/80/v2-0004258bd5cd7513f175c093a69b8777_720w.webp)  
    * HTTP请求状态行  
    请求行由请求Method, URL 字段和HTTP Version三部分构成, 总的来说请求行就是定义了本次请求的请求方式, 请求的地址, 以及所遵循的HTTP协议版本  
      ```
      GET /example.html HTTP/1.1 (CRLF)
      ```

    * HTTP请求头  
    消息报头由一系列的键值对组成，允许客户端向服务器端发送一些附加信息或者客户端自身的信息，主要包括：  
    ![img](https://pic2.zhimg.com/80/v2-8b50f49b69a70379a52b47060dcdf1f9_720w.webp)  

    * 请求体(正文)  
    只有在发送POST请求时才会有请求正文，GET方法并没有请求正文。  

  * 响应  
  HTTP响应也由三部分组成，包括状态行，消息报头，响应正文。  
    ![img](https://pic2.zhimg.com/80/v2-8eefa42df5c663cf259b39be57359bb1_720w.webp)  

    * HTTP响应状态行  
    状态行也由三部分组成，包括HTTP协议的版本，状态码，以及对状态码的文本描述。  
      ```
      HTTP/1.1 200 OK （CRLF）
      ```  

    * 消息报头  

    * 响应正文，例如：HTML


* HTTP长连接和短连接的区别  
在HTTP/1.0中采用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务中断连接；  
在HTTP/1.1默认采用长连接。就是保持连接。

  * 长连接适用的场景：长连接适用于操作频繁/点对点通讯等连接数不太多的情况，如：一些游戏/即时通讯场景应该使用长连接；

  * 短连接适用的场景： 短连接适用于大量连接的场景，如Web【wapWeb/H5等】的http服务，长连接对于服务端来说会耗费一定资源。  

* GET和POST的区别  
  * get把请求的数据放在url上， 以?分割URL和传输数据，参数之间以&相连，所以get不太安全。而post把数据放在HTTP的包体内（request body）

  * GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。

  * GET请求会被浏览器主动缓存，而POST不会，除非手动设置。  


# HTTPS  
HTTPS （全称：Hyper Text Transfer Protocol Secure），是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。
```
HTTP + 加密 + 认证 + 完整性保护 = HTTPS（HTTP Secure）
```
HTTPS工作在TCP协议443端口，其工作流程如下：  
* 浏览器将自己支持的一套加密规则发送给网站。
* 网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。
* 获得网站证书之后浏览器要做以下工作:  
  * 验证证书的合法性，否则会给出证书不受信的提示。
  * 如果证书受信任，浏览器会生成一串随机数的key，并用证书中提供的公钥加密。 
  * 使用约定好的HASH算法计算握手消息，并使用生成的key对消息进行加密，最后将之前生成的所有信息发送给网站。

* 网站接收浏览器发来的数据之后要做以下的操作： 
  * 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。 
  * 使用密码加密一段握手消息，发送给浏览器。

* 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。  

# HTTP和HTTPS的区别？
* 两者工作的端口号不同：HTTP工作在80，HTTPS工作在443；
* HTTPS需要用到CA（数字证书认证机构）申请证书，一般需要一定费用；
* HTTP响应比HTTPS快，主要因为HTTPS除了TCP3次握手外还要加上SSL9次握手共12次握手；
* HTTPS是构建在SSL/TLS上的HTTP协议，因此需要占用服务器资源。