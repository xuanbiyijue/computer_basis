# TCP 报文组成
![img](https://img-blog.csdnimg.cn/img_convert/1a7d952f8a1760c33c6e5e3d239af294.png)  
TCP 报文首部有 20 字节的固定首部以及最大长度为 40 字节的偏移数据构成，即 TCP 报文头部最大 60 字节  
* 端口号  
包括源端口号和目的端口号两部分，分别占 2 字节，用来标识同一台计算机的不同的应用进程。  
TCP 报头中的源端口号和目的端口号同 IP 数据报中的源 IP 与目的 IP 唯一确定一条 TCP 连接。  

* 序列号和确认号  
  * 序号是本报文段发送的数据组的第一个字节的序号。在 TCP 传送的流中，每一个字节一个序号。如一个报文段的序号为 300，此报文段数据部分共有 100 字节，则下一个报文段的序号为 400。所以序号确保了 TCP 传输的有序性。  
  * 确认号，指下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当 ACK 标志为 1 时才有效。比如建立连接时，SYN 报文的 ACK 标志位为 0。

  序号和确认号分别占 4 字节。  

* 数据偏移(或首部长度)  
因为首部可能含有可选项内容，因此 TCP 报头的长度是不确定的，首部长度实际上指示了数据区在报文段中的起始偏移值。


* 保留位与控制位  
每一个标志位表示一个控制功能：
  * URG：紧急指针标志，为 1 时表示紧急指针有效，为 0 则忽略紧急指针。
  * ACK：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。
  * PSH：push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。
  * RST：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。
  * SYN：同步序号，用于建立连接过程，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。
  * FIN：结束标志，用于释放连接，为 1 时表示发送方已经没有数据发送了，即关闭本方数据流。

* 窗口  
用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小是一个 16bit 的字段，因而窗口大小最大为 65535。  

* 校验和  
奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证。

* 紧急指针  
只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。

* 选项和填充  
最常见的可选字段是最长报文大小，又称为 MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置 SYN 标志为 1 的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是 32 位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证 TCP 头是 32 的整数倍。


# TCP 三次握手和四次挥手
![img](https://pic1.zhimg.com/80/v2-eb80a1d2475874f2ee9af3cb119d024c_720w.webp)  

1. **三次握手**：  
* 初始状态：一开始，客户端和服务端都处于 CLOSE 状态。先是服务端主动监听某个端口，处于 LISTEN 状态
* 第一次握手：客户端向服务端发送一个SYN报文段（此报文段的SYN标志位被置为1），表示请求建立连接，并随机生成一个初始序列号seq=x。客户端进入SYN-SENT状态，等待服务器的确认。
* 第二次握手：服务器收到SYN报文段后，如果同意建立连接，就向客户端发送一个SYN+ACK报文段。表示确认客户端的请求，并随机生成一个初始序列号seq=y。同时，服务器将确认号ack设置为x+1，表示期望收到客户端的下一个报文段的序号。服务器进入SYN-RECV状态。（问题来了，两次握手之后，站在客户端角度上思考：我发送和接收都ok，服务端的发送和接收也都ok。但是站在服务端的角度思考：哎呀，我服务端接收ok，但是我不清楚我的发送ok不ok呀，而且我还不知道你接受能力如何呢？所以老哥，你需要给我三次握手来传个话告诉我一声。你要是不告诉我，万一我认为你跑了，然后我可能出于安全性的考虑继续给你发一次，看看你回不回我。）
* 第三次握手： 客户端收到SYN+ACK报文段后，检查确认号是否为x+1，如果正确，就向服务器发送一个ACK报文段，表示确认服务器的响应，并将确认号ack设置为y+1，表示期望收到服务器的下一个报文段的序号。客户端进入ESTABLISHED状态。服务器收到ACK报文段后，检查确认号是否为y+1，如果正确，就进入ESTABLISHED状态。此时，TCP连接建立成功，双方可以开始传输数据。

2. **四次挥手**：因为TCP连接是全双工的，每个方向需要单独关闭，发送FIN标志。
* 数据传输结束后，客户端的应用进程停止发送数据并发送FIN标志以及seq=x+2, ACK = y+1，客户端进入FIN_WAIT_1状态，但此时客户端仍能收到服务器发来的数据；
* 服务器接收到FIN后，发送一个ACK = x+3给客户端，服务器进入CLOSE_WAIT状态，等待客户端确认，客户端接收确认后进入FIN_WAIT_2状态；
* 当服务器没有数据要发送时，发送一个FIN=1, seq=y+1报文，服务器进入LAST_ACK状态，等待客户端确认。
* 客户端收到服务器FIN报文后，发送ACK=y+1确认报文，客户端进入TIME_WAIT状态，等待2MSL(报文段最大生存时间)，然后关闭连接。  

> 为什么不使用两次握手  
> ![img](https://img-blog.csdnimg.cn/888598352d2342c58e3c8387abb492e4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ29kZXIgWHU=,size_20,color_FFFFFF,t_70,g_se,x_16)  

> 为什么 TIME_WAIT 需要等待 2MSL  
> MSL 即最大报文段生存时间，理论上四个报文都发送完毕后我们就可以直接进入 CLOSE 状态，但我们必须假设网络是不可靠的，最后一个 ACK 很可能丢失。所以 TIME_WAIT 状态就是用来重发可能丢失的 ACK 报文。  
> 在客户端发送出最后的 ACK 丢失后，服务端如果没有收到 ACK 将不断重复发送 FIN 片段。所以客户端不能立即关闭，它必须确认服务端接收到了最后的 ACK。客户端在发送出 ACK 之后进入到 TIME_WAIT 状态，同时会设置一个计时器，等待 2MSL 的时间。如果在该时间内再次收到 FIN，那么会重发ACK并再次等待 2MSL。  
> 所谓的 2MSL 是两倍的 MSL(Maximum Segment Lifetime)。MSL 指一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，客户端都没有再次收到 FIN，那么客户端推断 ACK 已经被成功接收，则结束 TCP 连接。

> 为何握手三次，挥手四次？  
> 因为当服务端收到客户端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK 报文是用来应答的，SYN 报文是用来同步的。而关闭连接时服务端收到 FIN 报文后很可能并不会立即关闭 SOCKET，所以只能先回复一个 ACK 报文给客户端，“你发的 FIN 报文我收到了”。只有等到服务端所有的报文都发送完了，才能发送 FIN 报文，因此不能一起发送。故需要四步握手。

> TIME_WAIT和CLOSE_WAIT的作用  
> CLOSE_WAIT的作用是等待本地用户发来的连接中断的请求。  
> TIME_WAIT主要有两个作用：
> * 防止前一个连接上延迟的数据包或者重传的数据包，被后面的复用连接错误的接收；
> * 确保主动连接方能在规定时间内，正常关闭连接；如果此时新建一个连接，源随机端口如果被复用，在 connect 发送 SYN 包后，由于被动方仍认为这条连接还在等待 ACK，但是却收到了 SYN，则被动方会回复 RST，造成主动创建连接的一方，由于收到了 RST，则连接无法成功  


# TCP的滑动窗口
TCP的滑动窗口是TCP协议中用于实现流量控制的一种机制。它能够动态调整发送方的发送速率，以避免网络拥塞。

滑动窗口由发送方维护，它指定了发送方可以发送的数据量。接收方会在每个ACK报文中携带窗口大小信息，告诉发送方当前接收方的接收能力。发送方根据接收方的窗口大小信息来调整自己的发送速率。

当网络拥塞时，接收方的接收能力会下降，它会通过减小窗口大小来通知发送方降低发送速率。当网络拥塞消失时，接收方的接收能力会恢复，它会通过增大窗口大小来通知发送方提高发送速率。  

TCP滑动窗口的基本原理是：
* TCP在每个报文段中设置一个窗口字段，表示接收方当前可接收的数据量，也就是接收方的窗口大小（RCV.WND）。
* 发送方根据接收方的窗口大小，确定自己的发送窗口（SND.WND），并在该窗口内连续发送多个报文段，而不必等待每个报文段的确认。
* 发送方维护两个指针：SND.UNA表示已发送但未确认的第一个字节序号，SND.NXT表示下一个要发送的字节序号。发送窗口的左边界是SND.UNA，右边界是SND.UNA+SND.WND。
* 接收方维护一个指针：RCV.NXT表示期望接收的下一个字节序号。接收方在收到报文段后，如果序号正确，就将其存入缓冲区，并向发送方发送确认（ACK），同时更新RCV.NXT和RCV.WND。如果序号不正确，就丢弃该报文段，并重复发送上一个ACK。
* 发送方在收到ACK后，就将确认的报文段从缓冲区中移除，并更新SND.UNA和SND.WND。如果ACK丢失或延迟，发送方会启动重传定时器，在超时后重传最早未确认的报文段。
* 发送方和接收方的窗口都会随着数据的发送和接收而“滑动”，即左右边界会向前移动，从而实现流量控制。

> 为什么要流量控制？  
通信双方在数据传输时，发送方的速率与接收方的速率是不一定相等，如果发送方的发送速率太快，会导致接收方处理不过来，这时候接收方只能把处理不过来的数据存在缓存区里（失序的数据包也会被存放在缓存区里）。如果缓存区满了发送方还在疯狂着发送数据，接收方只能把收到的数据包丢掉，大量的丢包会极大着浪费网络资源，因此，我们需要控制发送方的发送速率，让接收方与发送方处于一种动态平衡才好。


# TCP 如何保证可靠传输
* 数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据；
* 对失序数据包重排序：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层；
* 丢弃重复数据：对于重复数据，能够丢弃重复数据；
* 应答机制：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；
* 超时重发：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；
* 流量控制：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP 使用的流量控制协议是可变大小的滑动窗口协议。


# 拥塞控制
拥塞控制和流量控制不同，拥塞控制是一个全局性的过程，而流量控制是点对点通信量的控制。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。  
TCP的拥塞控制采用了四种算法，即：慢开始、拥塞避免、快重传和快恢复。
* 慢开始  
慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口(cwnd)数值。cwnd初始值为 1，每经过一个传播轮次，cwnd 加倍。

* 拥塞避免  
当 cwnd 增长到一个阈值 ssthresh 时，就开始使用拥塞避免算法，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1，进行线性增长。

  (以上是发送端在未检测到拥塞时所采用的积极避免拥塞的方法。接下来介绍拥塞发生时（可能发生在慢启动阶段或者拥塞避免阶段）拥塞控制的行为。)

* 快速重传和快速恢复  
  * 快重传: 要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方），而不要等到自己发送数据时捎带确认  
  * 快恢复: 发送方接收到三个重复 ACK 报文后，把慢开始门限 ssthresh 减半，并将 CWND 设置为新的 ssthresh，然后立即重传丢失的报文段，并开始进行拥塞避免算法。

![img](https://img-blog.csdnimg.cn/20190407180415884.png)



# TCP 粘包和拆包
一个完整的业务可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这个就是TCP的拆包和粘包问题。  

* TCP拆包的原因
  * 如果要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包
  * 如果待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包

* TCP粘包的原因
  * TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一包数据。若连续几次发送的数据都很少，通常TCP会根据优化算法把这些数据合成一包后一次发送出去，这样接收方就收到了粘包数据。
  * 如果接收方用户进程不及时接收数据，从而导致粘包现象。这是因为接收方先把收到的数据放在系统接收缓冲区，用户进程从该缓冲区取数据，若下一包数据到达时前一包数据尚未被用户进程取走，则下一包数据放到系统接收缓冲区时就接到前一包数据之后，而用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据，这样就一次取到了多包数据

* 对于粘包和拆包问题，常见的解决方案有四种：
  * 发送端将每个包都封装成固定的长度，比如100字节大小。如果不足100字节可通过补0或空等进行填充到指定长度。
  * 发送端在每个包的末尾使用固定的分隔符，例如\r\n。如果发生拆包需等待多个包发送过来之后再找到其中的\r\n进行合并。
  * 将消息分为头部和消息体，头部中保存整个消息的长度，只有读取到足够长度的消息之后才算是读到了一个完整的消息。
  * 通过自定义协议进行粘包和拆包的处理


# 确认重传机制
* 基于计时器的重传  
这种机制下，每个数据包都有相应的计时器，一旦超过 RTO(重传超时) 而没有收到 ACK，就重发该数据包。没收到 ACK 的数据包都会存在重传缓冲区里，等到 ACK 后，就从缓冲区里删除。  
对 TCP 来说，超时重传是相当重要的事件（RTO 往往大于两倍的 RTT(往返时延)，超时往往意味着拥塞），一旦发生这种情况，TCP 不仅会重传对应数据段，还会降低当前的数据发送速率，因为TCP 会认为当前网络发生了拥塞。  

* 快速重传  
基于计时器的重传往往要等待很长时间，而快速重传使用了很巧妙的方法来解决这个问题：服务器如果收到乱序的包，也给客户端回复 ACK，只不过是重复的 ACK。  
就拿刚刚的例子来说，收到乱序的包 6,7,8,9 时，服务器全都发 ACK = 5。这样，客户端就知道 5 发生了空缺。一般来说，如果客户端连续三次收到重复的 ACK，就会重传对应包，而不需要等到计时器超时。  
但快速重传仍然没有这个问题：到底该重传多少个包？

* 带选择确认的重传  
改进的方法就是 SACK（Selective Acknowledgment），简单来讲就是在快速重传的基础上，返回最近收到的报文段的序列号范围，这样客户端就知道，哪些数据包已经到达服务器了。


# TCP 中有哪些计时器  
TCP中有四种计时器，分别为：
* 重传计时器（Retransmission Timer）：用于控制丢失的报文段或者丢弃的报文段。
* 坚持计时器（Persistent Timer）：用于解决零窗口大小通知可能导致的死锁问题。
* 保活计时器（Keeplive Timer）：用于检测一个空闲的TCP连接是否仍然是保持着连接的状态。
* 时间等待计时器（Timer_Wait Timer）：用于在连接终止期间使用，确保对端有足够的时间收到最后一个ACK确认报文段，从而使TCP连接能够正常断开

# UDP  
* UDP 单播、广播和多播    
![img](https://img-blog.csdnimg.cn/img_convert/d929d0d7a7a96375a093ce4640521850.png)  
广播 UDP 与单播 UDP 的主要区别就是 IP 地址不同，广播使用广播地址 255.255.255.255，通过该 IP 地址可将消息发送到在同一广播网络上的每个主机。值得强调的是：本地广播信息是不会被路由器转发。广播地址通常用于在网络游戏中处于同一本地网络的玩家之间交流状态信息等。  

* 多播  
多播，也称为“组播”，将网络中同一业务类型主机进行了逻辑上的分组，进行数据收发的时候其数据仅仅在同一分组中进行，其他的主机没有加入此分组不能收发对应的数据。多播的应用主要有网上视频、网上会议等。

# TCP 和 UDP 区别  
* TCP是可靠传输，UDP是不可靠传输;
* TCP面向连接，UDP无连接，即发送数据之前不需要建立连接
* TCP传输数据有序，UDP不保证数据的有序性;
* TCP面向字节流，把数据看成一连串字节流，UDP是面向报文的
* TCP传输速度相对UDP较慢;
* TCP有流量控制和拥塞控制，UDP没有;
* TCP是重量级协议，UDP是轻量级协议;
* TCP首部20字节，UDP首部8字节;
* TCP连接只能是一对一的（端到端）；UDP支持一对一、一对多、多对一和多对多的通信方式。
![img](https://pic1.zhimg.com/80/v2-93041ef15eb684aba4992613803a1a98_720w.webp)
