# 1019. 链表中的下一个更大节点
https://leetcode.cn/problems/next-greater-node-in-linked-list/


## 题目描述
给定一个长度为 n 的链表 head

对于列表中的每个节点，查找下一个 更大节点 的值。也就是说，对于每个节点，找到它旁边的第一个节点的值，这个节点的值 严格大于 它的值。

返回一个整数数组 answer ，其中 answer[i] 是第 i 个节点( 从1开始 )的下一个更大的节点的值。如果第 i 个节点没有下一个更大的节点，设置 answer[i] = 0 。

## 示例
![img](https://assets.leetcode.com/uploads/2021/08/05/linkedlistnext1.jpg)
```
输入：head = [2,1,5]
输出：[5,5,0]
```

![img](https://assets.leetcode.com/uploads/2021/08/05/linkedlistnext2.jpg)
```
输入：head = [2,7,4,3,5]
输出：[7,0,5,5,0]
```


## 题解
* 方法1: 双指针(不如暴力破解)
```go
func nextLargerNodes(head *ListNode) []int {
    res := make([]int, 0)
    l, r := head, head.Next 
    for l != nil {
        if r == nil {
            res = append(res, 0)
            l = l.Next
            r = l
        } else if r.Val > l.Val {
            res = append(res, r.Val)
            l = l.Next
            r = l.Next
        } else if r.Val <= l.Val {
            r = r.Next
        }
    } 
    return res
}
```

* 方法2: 暴力破解
```
func nextLargerNodes(head *ListNode) []int {
    nodes := make([]*ListNode, 0)
    for p:=head; p!=nil; p=p.Next {
        nodes = append(nodes, p)
    }
    res := make([]int, len(nodes))
    for i:=0; i<len(res); i++ {
        for j:=i; j<len(res); j++ {
            if nodes[j].Val > nodes[i].Val {
                res[i] = nodes[j].Val
                break
            }
        }
    }
    return res
}
```