# 动态规划

## 解题步骤
* 确定dp数组（dp table）以及下标的含义
* 确定递推公式
* dp数组如何初始化
* 确定遍历顺序
* 举例推导dp数组


# 509. 斐波那契数列
https://leetcode.cn/problems/fibonacci-number/

## 题目描述
斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
```
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```
给定 n ，请计算 F(n) 。

## 示例
```
输入：n = 2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1
```
```
输入：n = 3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2
```
```
输入：n = 4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3
```

## 题解
* 题解1: 数组法。
```go
func fib(n int) int {
    values := []int{0, 1}
    if n < 2{
        return values[n]
    }
    for i:=2; i<=n; i++{
        values = append(values, values[i-1]+values[i-2])
    }
    return values[n]
}
```

* 题解2: 双数轮转法。
```go
func fib(n int) int {
    if n == 0 || n == 1 {
        return n
    }
    x1, x2 := 0, 1
    for i:=2; i<=n; i++ {
        x1, x2 = x2, x1+x2
    }
    return x2
}
```

* 题解3: 递归法
```go
func fib(n int) int {
    if n == 0 || n == 1 {
        return n
    }
    return fib(n-1) + fib(n-2)
}
```

* 题解4: 动态规划法
```go
func fib(n int) int {
    if n == 0 || n == 1 {
        return n
    }
    dp := make([]int, n+1)
    dp[1] = 1
    for i:=2; i<n+1; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }
    return dp[n]
}
```

# 爬楼梯
https://leetcode.cn/problems/climbing-stairs/

## 题目描述
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

## 示例
```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```
```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

## 题解
1. 确定dp数组以及下标含义  
dp[i]: 为爬到第i级楼梯有i种方法
2. 确定递推公式    
爬第i级楼梯有几种方法可由两个状态推出: 1. 爬到第i-1级有几种方法 2. 爬到第i-2级有几种方法。  
则  `dp[i] = dp[i-1] + dp[i-2]`
3. 初始化dp数组  
此处由于dp[0]不好定义，故不对其进行定义。  
`dp[1] = 1, dp[2] = 2`
4. 确定遍历顺序  
从前往后
5. 举例
```
func climbStairs(n int) int {
    if n==1{
        return 1
    }
    dp:=make([]int,n+1)
    dp[1]=1
    dp[2]=2
    for i:=3;i<=n;i++{
        dp[i]=dp[i-1]+dp[i-2]
    }
    return dp[n]
}
```
* 题解2: 双数轮转法
```go
func climbStairs(n int) int {
    if n == 1{
        return 1
    }
    if n == 2{
        return 2
    }
    m, l := 1, 2
    var result int
    for i:=3; i<=n; i++{
        result = m+l
        m, l = l, result
    }
    return result
}
```

# 746. 使用最小花费爬楼梯
https://leetcode.cn/problems/min-cost-climbing-stairs/

## 题目描述
给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

## 示例
```
输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。
```
```
输入：cost = [1,100,1,1,1,100,1,1,100,1]
输出：6
解释：你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。
```

## 题解
1. 确定dp数组  
dp[i]: 爬到第i个楼梯需要花费最少为dp[i]
2. 递推公式  
dp[i]可由两个方向推出：`dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])`
3. 初始化  
`dp[0] = 0, dp[1] = 0`
4. 遍历顺序  
从前往后
```go
func minCostClimbingStairs(cost []int) int {
    dp := make([]int, len(cost)+1)
    for i:=2; i<len(dp); i++ {
        dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])
    }
    return dp[len(dp)-1]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

# 53. 最大子数组和
https://leetcode.cn/problems/maximum-subarray/

## 题目描述
给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

## 示例
```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```
```
输入：nums = [1]
输出：1
```
```
输入：nums = [5,4,-1,7,8]
输出：23
```

## 题解
1. 定义dp数组  
dp[i]: 包含nums[i]的最大子数组和为dp[i]
2. 递推公式  
由dp[i]的定义可知，dp[i]必须由dp[i-1]推出，不然不是连续的。或者说不要dp[i-1]。`dp[i] = max(dp[i-1]+nums[i], nums[i])`
3. 初始化  
`dp[0] = nums[0]`  
4. 遍历顺序：从左往右
```go
func maxSubArray(nums []int) int {
    dp := make([]int, len(nums))
    dp[0] = nums[0]
    res := nums[0]
    for i:=1; i<len(dp); i++ {
        dp[i] = max(dp[i-1]+nums[i], nums[i])
        if dp[i] > res {
            res = dp[i]
        }
    }
    return res
}

func max(a, b int) int {
    if a > b {
        return a 
    }
    return b
}
```


# 152. 乘积最大子数组 
https://leetcode.cn/problems/maximum-product-subarray/

## 题目描述
给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。
测试用例的答案是一个 32-位 整数。

## 示例
```
给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个 32-位 整数。
```
```
输入: nums = [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
```

## 题解
此题类似上一题，首先定义dp数组：包含nums[i]的最大子数组和为dp[i] 。但是，由于负负得正，若是当前元素为绝对值大的负数，且后面的元素也存在负数，那么就得不出正确结果。即：**当前位置的最优解未必是由前一个位置的最优解转移得到的**。  
需要根据正负性进行讨论：  
* 考虑当前位置如果是一个负数的话，那么我们希望以它前一个位置结尾的某个段的积也是个负数，这样就可以负负得正，并且我们希望这个积尽可能「负得更多」，即尽可能小。
* 如果当前位置是一个正数的话，我们更希望以它前一个位置结尾的某个段的积也是个正数，并且希望它尽可能地大。  

那么，得出两个递推公式：  
* `max_dp[i] = max(max_dp[i-1]*nums[i], min_dp[i-1]*nums[i], nums[i])`
* `min_dp[i] = min(max_dp[i-1]*nums[i], min_dp[i-1]*nums[i], nums[i])`

综上：  
1. 定义dp数组  
使用二维dp数组，dp[0] 记录最大，dp[1] 记录最小。  
dp[0/1][i] 表示为以nums[i]结尾的最大/小的子数组。
2. 递推公式  
如上
3. 初始化  
dp[0][0], dp[1][0] = nums[i], nums[i]
4. 遍历顺序  
从前往后
```go
func maxProduct(nums []int) int {
    dp := make([][]int, 2)
    dp[0] = make([]int, len(nums))
    dp[1] = make([]int, len(nums))
    dp[0][0], dp[1][0] = nums[0], nums[0]
    for i:=1; i<len(nums); i++ {
        dp[0][i] = max(dp[0][i-1]*nums[i], dp[1][i-1]*nums[i], nums[i])
        dp[1][i] = min(dp[0][i-1]*nums[i], dp[1][i-1]*nums[i], nums[i])
    }
    // 扫描最大
    num_max := dp[0][0]
    for i:=1; i<len(nums); i++ {
        if dp[0][i] > num_max {
            num_max = dp[0][i]
        }
    }
    return num_max
}

func max(a, b, c int) int {
    if a >= b && a >= c {
        return a
    }
    if b >= a && b >= c {
        return b
    }
    if c >= a && c >= b {
        return c
    }
    return c
}

func min(a, b, c int) int {
    if a <= b && a <= c {
        return a
    }
    if b <= a && b <= c {
        return b
    }
    if c <= a && c <= b {
        return c
    }
    return c
}
```

## 总结  
* 类似这种求子数组的题，一般将dp数组设置为：dp[i]为以nums[i]结尾的



# 64. 最小路径和
链接: https://leetcode.cn/problems/minimum-path-sum/

## 题目描述
给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

## 示例
```
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
```
```
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
```

## 题解
1. dp数组定义  
用二维数组。dp[i][j] 表示为到达grid[i][j]的最小和
2. 递推公式  
dp[i][j]可由两个方向推出，dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]  
3. 初始化：  
dp[0][0] = grid[0][0], dp[0][j] = sum(grid[0][:j+1])
4. 遍历顺序：从前往后，从左到右
```go
func minPathSum(grid [][]int) int {
    dp := make([][]int, len(grid))
    for i:=0; i<len(dp); i++ {
        dp[i] = make([]int, len(grid[0]))
    }
    // 初始化
    dp[0][0] = grid[0][0]
    for i:=1; i<len(grid[0]); i++ {
        dp[0][i] = dp[0][i-1] + grid[0][i]
    }
    for i:=1; i<len(grid); i++ {
        dp[i][0] = dp[i-1][0] + grid[i][0]
    }
    // 遍历
    for i:=1; i<len(dp); i++ {
        for j:=1; j<len(dp[0]); j++ {
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
        }
    }
    return dp[len(dp)-1][len(dp[0])-1]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```


# 62. 不同路径
https://leetcode.cn/problems/unique-paths/

## 题目描述
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

## 示例
```
输入：m = 3, n = 7
输出：28
```
```
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```

## 题解
```go
func uniquePaths(m int, n int) int {
    dp := make([][]int, m)
    for i:=0; i<m; i++ {
        dp[i] = make([]int, n)
    }
    // 初始化
    for i:=0; i<n; i++ {
        dp[0][i] = 1
    }
    for i:=0; i<m; i++ {
        dp[i][0] = 1
    }
    // 遍历
    for i:=1; i<m; i++ {
        for j:=1; j<n; j++ {
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
        }
    }
    return dp[m-1][n-1]
}
```
```go
// 20230717
func uniquePaths(m int, n int) int {
    dp := make([][]int, m)
    for i:=0; i<m; i++ {
        dp[i] = make([]int, n)
        dp[i][0] = 1
        for j:=1; i==0&&j<n; j++ {dp[i][j] = 1}
    }
    for i:=1; i<m; i++ {
        for j:=1; j<n; j++ {
            dp[i][j] += (dp[i-1][j] + dp[i][j-1])
        }
    }
    return dp[m-1][n-1]
}
```

# 63. 不同路径2
https://leetcode.cn/problems/unique-paths-ii/

## 题目描述
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

网格中的障碍物和空位置分别用 1 和 0 来表示。

## 示例
![img](https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg)
```
输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```

## 题解
```go
func uniquePathsWithObstacles(obstacleGrid [][]int) int {
	m, n := len(obstacleGrid), len(obstacleGrid[0])
	// 定义一个dp数组
	dp := make([][]int, m)
	for i, _ := range dp {
		dp[i] = make([]int, n)
	}
	// 初始化, 如果是障碍物, 后面的就都是0, 不用循环了
	for i := 0; i < m && obstacleGrid[i][0] == 0; i++ {
		dp[i][0] = 1
	}
	for i := 0; i < n && obstacleGrid[0][i] == 0; i++ {
		dp[0][i] = 1
	}
	// dp数组推导过程
	for i := 1; i < m; i++ {
		for j := 1; j < n; j++ {
			// 如果obstacleGrid[i][j]这个点是障碍物, 那么dp[i][j]保持为0
			if obstacleGrid[i][j] != 1 {
				// 否则我们需要计算当前点可以到达的路径数
				dp[i][j] = dp[i-1][j] + dp[i][j-1]
			}
		}
	}
	return dp[m-1][n-1]
}
```
```go
// 20230717
func uniquePathsWithObstacles(obstacleGrid [][]int) int {
    dp := make([][]int, len(obstacleGrid))
    for i:=0; i<len(obstacleGrid); i++ {
        dp[i] = make([]int, len(obstacleGrid[0]))
        dp[i][0] = 1
        if obstacleGrid[i][0] == 1 || (i>0 && dp[i-1][0]==0) {
            dp[i][0] = 0
        }
    }
    for j:=0; j<len(obstacleGrid[0])&&obstacleGrid[0][j]==0; j++ {
        dp[0][j] = 1
    }
    for i:=1; i<len(obstacleGrid); i++ {
        for j:=1; j<len(obstacleGrid[0]); j++ {
            if obstacleGrid[i][j] != 1 {
                dp[i][j] += (dp[i-1][j] + dp[i][j-1])
            }
        }
    }
    return dp[len(obstacleGrid)-1][len(obstacleGrid[0])-1]
}
```



# 120. 三角形最小路径和
https://leetcode.cn/problems/triangle/

## 题目描述
给定一个三角形 triangle ，找出自顶向下的最小路径和。

每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。


## 示例
```
输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
输出：11
解释：如下面简图所示：
   2
  3 4
 6 5 7
4 1 8 3
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
```

## 题解
```go
func minimumTotal(triangle [][]int) int {
    if len(triangle) == 1 {
        return triangle[0][0]
    }
    dp := make([][]int, len(triangle))
    for i:=0; i<len(dp); i++ {
        dp[i] = make([]int, len(triangle[i]))
    } 
    // 初始化
    dp[0][0] = triangle[0][0]
    dp[1][0] = dp[0][0] + triangle[1][0]
    dp[1][1] = dp[0][0] + triangle[1][1]
    // 遍历
    for i:=2; i<len(dp); i++ {
        dp[i][0] = dp[i-1][0] + triangle[i][0]
        dp[i][i] = dp[i-1][i-1] + triangle[i][i]
        for j:=1; j<i;  j++ {
            dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + triangle[i][j]
        }
    }
    res := dp[len(dp)-1][0]
    for i:=1; i<len(dp[len(dp)-1]); i++ {
        if dp[len(dp)-1][i] < res {
            res = dp[len(dp)-1][i]
        }
    }
    return res
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

# 343. 整数拆分
https://leetcode.cn/problems/integer-break/  

## 题目描述
给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。

返回 你可以获得的最大乘积 。

## 示例
```
输入: n = 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```
```
输入: n = 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```

## 题解
对于整数 i ，我们可以先从中拆出一个数，变成两个数：[(i-j), j], 那么 dp[i] 就可以由两个方向推出：
* 不继续拆分，dp[i] = (i-j) * j
* 继续拆分 j，dp[i] = (i-j) * dp[j]

最后选择最大那个

```go
func integerBreak(n int) int {
    dp := make([]int, n+1)
    dp[1] = 1
    for i:=2; i<n+1; i++ {
        for j:=1; j<i; j++ {
            dp[i] = max(dp[i], max((i-j) * j, (i-j) * dp[j]))
        }
    }
    return dp[n]
}

func max(a, b int) int {if a > b {return a}; return b}
```

# 121. 买卖股票的最佳时机
https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/


## 题目描述
给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

## 示例
```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```
```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

## 题解
1. 确定dp数组（dp table）以及下标的含义  
dp[i][0] 表示第i天持有股票所得最多现金 ，这里可能有同学疑惑，本题中只能买卖一次，持有股票之后哪还有现金呢？
其实一开始现金是0，那么加入第i天买入股票现金就是 -prices[i]， 这是一个负数。  
dp[i][1] 表示第i天不持有股票所得最多现金
注意这里说的是“持有”，“持有”不代表就是当天“买入”！也有可能是昨天就买入了，今天保持持有的状态

2. 确定递推公式  
如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来：
   * 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][0]
   * 第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i]

   那么dp[i][0]应该选所得现金最大的，所以dp[i][0] = max(dp[i - 1][0], -prices[i]);  

   如果第i天不持有股票即dp[i][1]， 也可以由两个状态推出来：

   * 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1][1]
   * 第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：prices[i] + dp[i - 1][0]  

   同样dp[i][1]取最大的，dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);

3. dp数组如何初始化  
其基础都是要从dp[0][0]和dp[0][1]推导出来。  
那么dp[0][0]表示第0天持有股票，此时的持有股票就一定是买入股票了，因为不可能有前一天推出来，所以dp[0][0] -= prices[0];  
dp[0][1]表示第0天不持有股票，不持有股票那么现金就是0，所以dp[0][1] = 0;

4. 遍历顺序  
从前往后

```go
func maxProfit(prices []int) int {
    // 定义dp数组
    dp := make([][]int, len(prices))
    for i:=0; i<len(dp); i++ {
        dp[i] = make([]int, 2)
    }
    // 初始化
    dp[0][0], dp[0][1] = -prices[0], 0
    // 遍历
    for i:=1; i<len(dp); i++ {
        dp[i][0] = max(dp[i-1][0], -prices[i])
        dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i])
    }
    return dp[len(dp)-1][1]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```


# 122. 买卖股票的最佳时机2
https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/

## 题目描述
给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。

返回 你能获得的 最大 利润 。

 
## 示例
```
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
     总利润为 4 + 3 = 7 。
```
```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     总利润为 4 。
```
```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。
```

## 题解
```go
func maxProfit(prices []int) int {
    dp := make([][]int, len(prices))
    for i:=0; i<len(dp); i++ {
        dp[i] = make([]int, 2)
    }
    // 初始化
    dp[0][0], dp[0][1] = -prices[0], 0
    for i:=1; i<len(dp); i++ {
        dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i])
        dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i])
    }
    return dp[len(dp)-1][1]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

# 123. 买卖股票的最佳时机
https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/

## 题目描述
给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

## 示例
```
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
```
```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```
```
输入：prices = [7,6,4,3,1] 
输出：0 
解释：在这个情况下, 没有交易完成, 所以最大利润为 0。
```

## 题解
1. 确定dp数组以及下标的含义  
一天一共就有五个状态，
   * 没有操作
   * 第一次买入
   * 第一次卖出
   * 第二次买入
   * 第二次卖出  
   
   dp[i][j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i][j]表示第i天状态j所剩最大现金。

2. 确定递推公式  
需要注意：dp[i][1]，表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票，这是很多同学容易陷入的误区。  
达到dp[i][1]状态，有两个具体操作：
   * 操作一：第i天买入股票了，那么dp[i][1] = dp[i-1][0] - prices[i]
   * 操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] = dp[i - 1][1]  
dp[i][1] = max(dp[i-1][0] - prices[i], dp[i - 1][1]);

   同理dp[i][2]也有两个操作：
   * 操作一：第i天卖出股票了，那么dp[i][2] = dp[i - 1][1] + prices[i]  
   * 操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] = dp[i - 1][2]  
所以dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])

   同理可推出剩下状态部分：  
dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);  
dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);

3. dp数组如何初始化  
第0天没有操作，这个最容易想到，就是0，即：dp[0][0] = 0;  
第0天做第一次买入的操作，dp[0][1] = -prices[0];  
第0天做第一次卖出的操作，这个初始值应该是多少呢？  
首先卖出的操作一定是收获利润，整个股票买卖最差情况也就是没有盈利即全程无操作现金为0，  
从递推公式中可以看出每次是取最大值，那么既然是收获利润如果比0还小了就没有必要收获这个利润了。  
所以dp[0][2] = 0;  
第0天第二次买入操作，初始值应该是多少呢？应该不少同学疑惑，第一次还没买入呢，怎么初始化第二次买入呢？  
二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后在买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。  
所以第二次买入操作，初始化为：dp[0][3] = -prices[0];  
同理第二次卖出初始化dp[0][4] = 0;
```go
func maxProfit(prices []int) int {
    dp:=make([][]int,len(prices))
    for i:=0;i<len(prices);i++{
        dp[i]=make([]int,5)
    }
    dp[0][0]=0
    dp[0][1]=-prices[0]
    dp[0][2]=0
    dp[0][3]=-prices[0]
    dp[0][4]=0
    for i:=1;i<len(prices);i++{
        dp[i][0]=dp[i-1][0]
        dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i])
        dp[i][2]=max(dp[i-1][2],dp[i-1][1]+prices[i])
        dp[i][3]=max(dp[i-1][3],dp[i-1][2]-prices[i])
        dp[i][4]=max(dp[i-1][4],dp[i-1][3]+prices[i])
    }
    return dp[len(prices)-1][4]
}
func max(a,b int)int{
    if a>b{
        return a
    }
    return b
}
```


# 198. 打家劫舍
https://leetcode.cn/problems/house-robber/

## 题目描述
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

## 示例
```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```
```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

## 题解
1. 确定dp数组  
dp[i]: 前i间最多能偷盗dp[i]的金额

2. 递推公式  
dp[i]取决于第i间房偷不偷。如果偷，那么就一定不偷前一间：dp[i-2] + nums[i]. 如果不偷，那么就要考虑前一间（可以不偷）: dp[i-1].  
dp[i] = max(dp[i-2]+nums[i], dp[i-1])

3. 初始化  
`dp[0], dp[1] = nums[0], max(nums[0], nums[1])`

4. 遍历顺序  
从前往后   
```go
func rob(nums []int) int {
    if len(nums) == 1 {
        return nums[0]
    }
    if len(nums) == 2 {
        return max(nums[0], nums[1])
    }
    dp := make([]int, len(nums))
    dp[0], dp[1] = nums[0], max(nums[0], nums[1])
    for i:=2; i<len(nums); i++ {
        dp[i] = max(dp[i-2]+nums[i], dp[i-1])
    }
    return dp[len(dp)-1]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

# 213. 打家劫舍2
https://leetcode.cn/problems/house-robber-ii/

## 题目描述
你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。

## 示例
```
输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
```
```
输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

## 题解
对于一个数组，成环的话主要有如下三种情况：
* 考虑不包含首尾元素
* 考虑包含首元素，不包含尾元素
* 考虑包含尾元素，不包含首元素

注意我这里用的是"考虑"，例如情况三，虽然是考虑包含尾元素，但不一定要选尾部元素  
而情况二 和 情况三 都包含了情况一了，所以只考虑情况二和情况三就可以了。
```go
func rob(nums []int) int {
    if len(nums) == 1 {
        return nums[0]
    }
    if len(nums) == 2 {
        return max(nums[0], nums[1])
    }
    
    result1 := robRange(nums, 0)
    result2 := robRange(nums, 1)
    return max(result1, result2)
}

// 偷盗指定的范围
func robRange(nums []int, start int) int {
    dp := make([]int, len(nums))
    dp[1] = nums[start]
    
    for i := 2; i < len(nums); i++ {
        dp[i] = max(dp[i - 2] + nums[i - 1 + start], dp[i - 1])
    }
    
    return dp[len(nums) - 1]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```


# 647. 回文子串
https://leetcode.cn/problems/palindromic-substrings/

## 题目描述
给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。

回文字符串 是正着读和倒过来读一样的字符串。

子字符串 是字符串中的由连续字符组成的一个序列。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。


## 示例
```
输入：s = "abc"
输出：3
解释：三个回文子串: "a", "b", "c"
```
```
输入：s = "aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
```

## 题解
1. 确定dp数组（dp table）以及下标的含义  
布尔类型的dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false。

2. 确定递推公式  
在确定递推公式时，就要分析如下几种情况。  
整体上是两种，就是s[i]与s[j]相等，s[i]与s[j]不相等这两种。  
当s[i]与s[j]不相等，那没啥好说的了，dp[i][j]一定是false。  
当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况  
情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串  
情况二：下标i 与 j相差为1，例如aa，也是回文子串  
情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，**这个区间是不是回文就看dp[i + 1][j - 1]是否为true**。

3. dp数组如何初始化  
dp[i][j]初始化为false。

4. 确定遍历顺序  
从下到上，从左到右遍历

```go
func countSubstrings(s string) int {
    res:=0
    // 初始化dp数组
    dp:=make([][]bool,len(s))
    for i:=0;i<len(s);i++{
        dp[i]=make([]bool,len(s))
    }
    // 开始遍历
    for i:=len(s)-1;i>=0;i--{
        for j:=i;j<len(s);j++{
            if s[i]==s[j]{
                if j-i<=1{
                    res++
                    dp[i][j]=true
                }else if dp[i+1][j-1]{
                    res++
                    dp[i][j]=true
                }
            }
        }
    }
    return res
}
```


# 5. 最长回文子串
https://leetcode.cn/problems/longest-palindromic-substring/

## 题目描述
给你一个字符串 s，找到 s 中最长的回文子串。

如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。

## 示例
```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```
```
输入：s = "cbbd"
输出："bb"
```

## 题解
使用二维布尔类型dp数组。  
1. dp数组的定义  
dp[i][j]: 下标从i到j的子串是否回文  

2. 递推公式  
如果s[i]不等于s[j]，那必然不是回文。  
如果s[i]等于s[j]，那么就要分情况讨论：
   * 如果i和j指向的同一个或者相邻，那么就是回文  
   * 否则，就看dp[i+1][j-1]

3. 初始化  
全部初始化false  

4. 遍历顺序  
从下到上，从左到右  

```go
func longestPalindrome(s string) string {
    res, length := "", 0
    // dp数组
    dp := make([][]bool, len(s))
    for i:=0; i<len(s); i++ {
        dp[i] =  make([]bool, len(s))
    }
    // 遍历
    for i:=len(s)-1; i>=0; i-- {
        for j:=i; j<len(s); j++ {
            // 如果首尾相同才进行判断
            if s[i] == s[j] {
                if j-i <= 1 {
                    dp[i][j] = true
                } else if dp[i+1][j-1] {
                    dp[i][j] = true
                }
            }
            // 如果是回文
            if dp[i][j] && j-i+1>length {
                length = j-i+1
                res = s[i:j+1]
            }
        }
    } 
    return res
}
```


# 97. 交错字符串
https://leetcode.cn/problems/interleaving-string/

## 题目描述
给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。

两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：

s = s1 + s2 + ... + sn  
t = t1 + t2 + ... + tm  
|n - m| <= 1  
交错 是 s1 + t1 + s2 + t2 + s3 + t3 + ... 或者 t1 + s1 + t2 + s2 + t3 + s3 + ...  
注意：a + b 意味着字符串 a 和 b 连接。
![img](https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg)

## 示例
```
输入：s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
输出：true
```
```
输入：s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"
输出：false
```

## 题解
设dp[i][j]表示为s1的前i个字母和s2的前j个字母能否交错组成s3的前i+j个字母。如果s1[i]==s3[i+j]，那么dp[i][j]取决于dp[i-1][j]。同理，如果s2[j]==s3[i+j]，那么dp[i][j]取决于dp[i][j-1]。
```go
func isInterleave(s1 string, s2 string, s3 string) bool {
    n, m, t := len(s1), len(s2), len(s3)
    if (n + m) != t {
        return false
    }
    f := make([][]bool, n + 1)
    for i := 0; i <= n; i++ {
        f[i] = make([]bool, m + 1)
    }
    f[0][0] = true
    for i := 0; i <= n; i++ {
        for j := 0; j <= m; j++ {
            p := i + j - 1
            if i > 0 {
                f[i][j] = (f[i-1][j] && s1[i-1] == s3[p])
            }
            if j > 0 {
                f[i][j] = f[i][j] || (f[i][j-1] && s2[j-1] == s3[p])
            }
        }
    }
    return f[n][m]
}
```

* 错误解法
```go
func isInterleave(s1 string, s2 string, s3 string) bool {
    if len(s1) + len(s2) != len(s3) {
        return false
    }
    dict := make(map[int]bool)
    p1, p2, p3 := 0, 0, 0
    for p1<len(s1) && p3<len(s3) {
        if s1[p1] == s3[p3] {
            dict[p3] = true
            p1++
        }
        p3++
    }
    if p1 != len(s1) {
        return false
    }
    p3 = 0
    for p2<len(s2) && p3<len(s3) {
        if dict[p3] {
            p3++
            continue
        }
        if s2[p2] != s3[p3] {
            return false 
        }
        p2++
        p3++
    }
    return true
}
// 不能用此方法，因为s1和s2可能有重复字母，发生占用
```


# 139. 单词拆分
https://leetcode.cn/problems/word-break/

## 题目描述
给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。

注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。


## 示例
```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
```
```
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
     注意，你可以重复使用字典中的单词。
```
```
输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
```

## 题解
1. dp数组的定义  
dp[i]: 字符串s的前i个字符组成的子串能否由单词列表中的词组成  
2. 递推公式  
dp[i] = dp[j] && check(s[j..i−1])  
3. 初始化  
dp[0] = true
```go
func wordBreak(s string, wordDict []string) bool {
    // 创建hash表来判断是否出现在单词列表
    wordDictSet := make(map[string]bool)
    for _, w := range wordDict {
        wordDictSet[w] = true
    }
    // 定义dp数组
    dp := make([]bool, len(s) + 1)
    dp[0] = true
    for i := 1; i <= len(s); i++ {
        for j := 0; j < i; j++ {
            if dp[j] && wordDictSet[s[j:i]] {
                dp[i] = true
                break
            }
        }
    }
    return dp[len(s)]
}
```

# 787. K 站中转内最便宜的航班(DP)
https://leetcode.cn/problems/cheapest-flights-within-k-stops/

## 题目描述
有 n 个城市通过一些航班连接。给你一个数组 flights ，其中 flights[i] = [fromi, toi, pricei] ，表示该航班都从城市 fromi 开始，以价格 pricei 抵达 toi。

现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到出一条最多经过 k 站中转的路线，使得从 src 到 dst 的 价格最便宜 ，并返回该价格。 如果不存在这样的路线，则输出 -1。


## 示例
![img](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png)
```
输入: 
n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
src = 0, dst = 2, k = 1
输出: 200
解释: 
从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。
```
![img](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png)
```
输入: 
n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
src = 0, dst = 2, k = 0
输出: 500
```

## 题解
用 f[t][i] 表示通过恰好 t 次航班，从出发城市 src 到达城市 i 需要的最小花费。则递推公式：
f[t][i]= min{f[t−1][j]+cost(j,i)}

由于我们最多只能中转 k 次，也就是最多搭乘 k+1 次航班，最终的答案即为 f[1][dst],f[2][dst],⋯,f[k+1][dst] 中的最小值。  

当 t=0 时，状态 f[t][i] 表示不搭乘航班到达城市 i 的最小花费，因此有：
* i = src: 0
* i != src: 无穷大

根据题目中给出的数据范围，航班的花费不超过 10000，最多搭乘航班的次数 k+1 不超过 101，那么在实际的代码编写中，我们只要使得极大值大于10000×101，就可以将表示不合法状态的极大值与合法状态的花费进行区分。
```go
func findCheapestPrice(n int, flights [][]int, src int, dst int, k int) int {
    const inf = 10000*101 + 1
    f := make([][]int, k+2)
    for i := range f {
        f[i] = make([]int, n)
        for j := range f[i] {
            f[i][j] = inf
        }
    }
    f[0][src] = 0
    for t := 1; t <= k+1; t++ {
        for _, flight := range flights {
            j, i, cost := flight[0], flight[1], flight[2]
            f[t][i] = min(f[t][i], f[t-1][j]+cost)
        }
    }
    ans := inf
    for t := 1; t <= k+1; t++ {
        ans = min(ans, f[t][dst])
    }
    if ans == inf {
        ans = -1
    }
    return ans
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```


# 96. 不同的二叉搜索树
https://leetcode.cn/problems/unique-binary-search-trees/
>扩展：不同的二叉搜索树2，在回溯篇


## 题目描述
给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。


## 示例
```
输入：n = 3
输出：5
```
```
输入：n = 1
输出：1
```

## 题解
dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量

元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量

元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量

元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量

有2个元素的搜索树数量就是dp[2]。

有1个元素的搜索树数量就是dp[1]。

有0个元素的搜索树数量就是dp[0]。

所以dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]
```go
func numTrees(n int) int {
    dp := make([]int, n+1)
    dp[0], dp[1] = 1, 1 
    // 当长度为i时，有几个不同的树
    for i:=2; i<=n; i++ {
        // 从1...i中选择节点j做根
        for j:=1; j<=i; j++ {
            dp[i] += dp[j-1] * dp[i-j]
        } 
    }
    return dp[n]
}
```


# 1031. 两个非重叠子数组的最大和
https://leetcode.cn/problems/maximum-sum-of-two-non-overlapping-subarrays/

## 题目描述
给你一个整数数组 nums 和两个整数 firstLen 和 secondLen，请你找出并返回两个非重叠 子数组 中元素的最大和，长度分别为 firstLen 和 secondLen 。

长度为 firstLen 的子数组可以出现在长为 secondLen 的子数组之前或之后，但二者必须是不重叠的。

子数组是数组的一个 连续 部分。

## 示例
```
输入：nums = [0,6,5,2,2,5,1,9,4], firstLen = 1, secondLen = 2
输出：20
解释：子数组的一种选择中，[9] 长度为 1，[6,5] 长度为 2。
```
```
输入：nums = [3,8,1,3,2,1,8,9,0], firstLen = 3, secondLen = 2
输出：29
解释：子数组的一种选择中，[3,8,1] 长度为 3，[8,9] 长度为 2。
```

## 题解
由题目可知，firstLen 要么在左边，要么在右边。那么我们只需要搜索两次就行。  
易见，这题用动态规划：
* dp数组定义  
dp[i]: 表示为下标在[0, i]区间内的长度为 firstLen的子数组最大和
* 递推公式  
随着滑动窗口向右移动，dp[i]的值要么不变，要么就是以最右端结尾的子数组的和：dp[i] = max(dp[i-1], sum(nums[[i+1−firstLen:i+1]))  
* 初始化  
长度不够firstLen的dp[i] = 0  

那么，对于第二个子数组 sum(nums[j:j+secondLen])，其对应第一个数组最大和就是dp[j-1]。那么，最大和就是 dp[j-1] + sum(nums[j:j+secondLen])  
最后再遍历一次得到最大值：
```go
func maxSumTwoNoOverlap(nums []int, firstLen int, secondLen int) int {
    return max(helper(nums, firstLen, secondLen), helper(nums, secondLen, firstLen))
}

func helper(nums []int, firstLen int, secondLen int) int {
    dp := make([]int, len(nums))
    for i:=0; i<firstLen; i++ {
        dp[firstLen-1] += nums[i]
    }
    // 记录前缀和
    preTotal := dp[firstLen-1]
    for i:=firstLen; i<len(dp)-secondLen; i++ {
        preTotal = preTotal + nums[i] - nums[i-firstLen]
        // 随着滑动窗口向右移动，dp[i]的值要么不变，要么就是以最右端结尾的子数组的和
        dp[i] = max(dp[i-1], preTotal)
    }
    // 计算最大和
    rTotal := 0
    for j:=firstLen; j<firstLen+secondLen; j++ {
        rTotal += nums[j]
    }
    res := dp[firstLen-1] + rTotal
    for j:=firstLen+1; j<=len(dp)-secondLen; j++ {
        rTotal = rTotal + nums[j+secondLen-1] - nums[j-1]
        res = max(res, dp[j-1] + rTotal)
    }
    return res 
}

func max(a, b int) int {if a > b {return a}; return b}
```


-------------------------------------------------------
-----------------------------------------------------------



# 01背包问题
有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。  


背包最大重量为4。

物品为：   
&nbsp; &nbsp; &nbsp; &nbsp;   重量	价值  

物品0	1	15  
物品1	3	20  
物品2	4	30  
问背包能背的物品最大价值是多少？

## 二维DP数组
1. 确定dp数组以及下标的含义  
对于背包问题，有一种写法， 是使用二维数组，即dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。
![img](https://img-blog.csdnimg.cn/20210110103003361.png)

2. 确定递推公式  
再回顾一下dp[i][j]的含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。  
那么可以有两个方向推出来dp[i][j]，
* 不放物品i：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)
* 放物品i：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值  
所以递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

3. dp数组如何初始化  
首先从dp[i][j]的定义出发，如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0。  
在看其他情况。状态转移方程 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。  
dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值,那么很明显当 j < weight[0]的时候，dp[0][j] 应该是 0，因为背包容量比编号0的物品重量还小。当j >= weight[0]时，dp[0][j] 应该是value[0]，因为背包容量放足够放编号0物品。
![img](https://img-blog.csdnimg.cn/20210110103109140.png)

4. 确定遍历顺序  
有两个遍历的维度：物品与背包重量  
先遍历物品更好理解。


完整代码：
```go
func test_2_wei_bag_problem1(weight, value []int, bagweight int) int {
	// 定义dp数组
	dp := make([][]int, len(weight))
	for i, _ := range dp {
		dp[i] = make([]int, bagweight+1)
	}
	// 初始化
	for j := bagweight; j >= weight[0]; j-- {
		dp[0][j] = dp[0][j-weight[0]] + value[0]
	}
	// 递推公式
	for i := 1; i < len(weight); i++ {
		//正序,也可以倒序
	    for j := 0; j <= bagweight; j++ {
	        if j < weight[i] {
	            dp[i][j] = dp[i-1][j]
	        } else {
	            dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i])
	        }
	    }		
	}
	return dp[len(weight)-1][bagweight]
}

func max(a,b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	weight := []int{1,3,4}
	value := []int{15,20,30}
	test_2_wei_bag_problem1(weight,value,4)
}
```

## 一维dp数组
1. 确定dp数组的定义  
在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。
2. 一维dp数组的递推公式  
dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。  
dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）  
此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，  
`dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);`  
3. 一维dp数组如何初始化  
都初始为0就可以了。  
4. 一维dp数组遍历顺序
```
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
```

完整代码：
```go
func test_1_wei_bag_problem(weight, value []int, bagWeight int) int {
	// 定义 and 初始化
	dp := make([]int,bagWeight+1)
	// 递推顺序
	for i := 0 ;i < len(weight) ; i++ {
		// 这里必须倒序,区别二维,因为二维dp保存了i的状态
		for j:= bagWeight; j >= weight[i] ; j-- {
			// 递推公式
			dp[j] = max(dp[j], dp[j-weight[i]]+value[i])
		}
	}
	//fmt.Println(dp)
	return dp[bagWeight]
}

func max(a,b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	weight := []int{1,3,4}
	value := []int{15,20,30}
	test_1_wei_bag_problem(weight,value,4)
}
```


# 416. 分割等和子集
https://leetcode.cn/problems/partition-equal-subset-sum/

## 题目描述
给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

## 示例
```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```
```
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```

## 题解
此题可用01背包进行求解。将题目看成：存在一个容量为total/2的背包，是否能够将其刚刚装满。
1. dp数组: dp[j]为容量为j的背包能够装的最大价值
2. 递推公式：dp[j] = max(dp[j], dp[j-nums[i]]+nums[i])
3. 初始化: 全为0
4. 遍历顺序: 先物品(从小到大)后背包容量(从大到小)

```go
func canPartition(nums []int) bool {
    if len(nums) == 1 {return false}
    total := sum(nums)
    if total % 2 == 1 {return false}
    cap := total / 2
    dp := make([]int, cap+1)
    for i:=0; i<len(nums); i++ {
        // 背包容量要确保比物品大
        for j:=cap; j>=nums[i]; j-- {
            dp[j] = max(dp[j], dp[j-nums[i]]+nums[i])
        }
    }
    return dp[cap] == cap
}

func sum(nums []int) int {
    total := 0
    for _, value := range nums {
        total += value
    }
    return total
}

func max(a, b int) int {if a > b {return a}; return b}
```

```go
// 20230726
func canPartition(nums []int) bool {
    // 先得出总和
    total := 0
    for _, num := range nums {total += num}
    if total % 2 != 0 {return false}
    // 计算背包容量，即一半的总和
    cap := total / 2
    // dp
    dp := make([]int, cap + 1)
    for i:=0; i<len(nums); i++ {
        for j:=cap; j>=nums[i]; j-- {
            dp[j] = max(dp[j], dp[j-nums[i]] + nums[i])
        }
    }
    return dp[cap] == cap
}

func max(a, b int) int {if a > b {return a}; return b}
```


# 1049. 最后一块石头的重量 II
https://leetcode.cn/problems/last-stone-weight-ii/

## 题目描述
有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。

每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

如果 x == y，那么两块石头都会被完全粉碎；
如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。

## 示例
```
输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
```
```
输入：stones = [31,26,33,21,40]
输出：5
```

## 题解
此题本质上就是将石头尽可能分成均等的两堆。同样可以用背包问题进行求解。
```go
func lastStoneWeightII(stones []int) int {
    if len(stones) == 1 {return stones[0]}
	total := 0
    for _, s := range stones {total += s}
    avg := total / 2

    dp := make([]int, avg+1)
    for _, s := range stones {
        for j:=avg; j>=s; j-- {
            dp[j] = max(dp[j], dp[j-s]+s)
        }
    }
    return total - 2 * dp[avg]
}

func max (a, b int) int {if a > b {return a}; return b}
```
```go
// 20230726
func lastStoneWeightII(stones []int) int {
    total := 0
    for _, num := range stones {total += num}
    cap := total / 2
    dp := make([]int, cap + 1)
    for _, stone := range stones {
        for j:=cap; j>=stone; j-- {
            dp[j] = max(dp[j], dp[j-stone]+stone)
        }
    }
    return total - 2 * dp[cap]
}

func max(a, b int) int {if a > b {return a}; return b}
```

# 494. 目标和
https://leetcode.cn/problems/target-sum/  

## 题目描述
给你一个整数数组 nums 和一个整数 target 。

向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：

例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。

## 示例
```
输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```

## 题解
将所有数分为正数和负数两堆。那么必然有 left - right = target, left + right = total  
所以，left = target + right, target + 2 * right = total  
right = (total - target) / 2  
那么题目就可以转变为：从 nums 中挑选若干个数字装满容量为 right 的背包有多少种方法  
递推公式为：dp[i] = sum(dp[j]) j<i
```go
func findTargetSumWays(nums []int, target int) int {
    total := 0
    for _, num := range nums {total += num}
    if total < target {return 0}
    var cap int
    if cap=total-target; cap%2!=0 {return 0}
    cap /= 2
    dp := make([]int, cap+1)
    dp[0] = 1
    for _, num := range nums {
        for j:=cap; j>=num; j-- {
            dp[j] += dp[j-num]
        }
    }
    return dp[cap]
}
```

# 474. 一和零
https://leetcode.cn/problems/ones-and-zeroes/  

## 题目描述
给你一个二进制字符串数组 strs 和两个整数 m 和 n 。

请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。

如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

## 示例
```
输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。
```

## 题解
// 本题有2个指标，可以考虑使用二维数组, 因为是两个维度的背包  
// dp[i][j]: 最多i个0和j个1的子集最大长度  
// 那么dp[i][j]可以由以下方向推出：  
// 遍历当前物品，如果加入这个物品，那么 dp[i][j] = dp[i-zeroNum][j-oneNum] + 1  
// 如果不加入，那么 dp[i][j] = dp[i][j]  
// 因此，dp[i][j] = max(dp[i][j], dp[i-zeroNum][j-oneNum]+1)    
```go
func findMaxForm(strs []string, m int, n int) int {
    dp := make([][]int, m+1)
    for i:=0; i<=m; i++ {
        dp[i] = make([]int, n+1)
    }
    for _, str := range strs {
        zeroNum, oneNum := 0, 0
        for _, ch := range str {
            if ch=='0' {zeroNum++} else {oneNum++}
        }
        for i:=m; i>=zeroNum; i-- {
            for j:=n; j>=oneNum; j-- {
                dp[i][j] = max(dp[i][j], dp[i-zeroNum][j-oneNum]+1)
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {if a > b {return a}; return b}
```
