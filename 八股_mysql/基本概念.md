# 三大范式
* 第一范式（1NF）：字段（或属性）是不可分割的最小单元，即不会有重复的列，体现原子性
* 第二范式（2NF）：满足 1NF 前提下，存在一个候选码，非主属性全部依赖该候选码（消除部分函数依赖）
* 第三范式（3NF）：满足 2NF 前提下，非主属性必须互不依赖，消除传递依赖

# COUNT()函数
统计数据表中包含的记录行的总数，或者根据查询结果返回列中包含的数据行数，它有两种用法：
* COUNT(*)计算表中总的行数，不管某列是否有数值或者为空值。
* COUNT(字段名)计算指定列下总的行数，计算时将忽略空值的行。  

COUNT()函数可以与GROUP BY一起使用来计算每个分组的总和。


# SQL 注入
SQL注入的原理是将SQL代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法。  
举个例子：

比如我们的登录功能，其登录界面包括用户名和密码输入框以及提交按钮，登录时需要输入用户名和密码，然后提交。此时调用接口: `/user/login/`, 加上参数username、password，首先连接数据库，然后后台对请求参数中携带的用户名、密码进行参数校验，即SQL的查询过程。假设正确的用户名和密码为ls和123456，输入正确的用户名和密码、提交，相当于调用了以下的SQL语句:  
```sql
SELECT * FROM user WHERE username = 'ls' AND password = '123456'
```  
SQL中会将#及--以后的字符串当做注释处理，如果我们使用 `' or 1=1 #` 作为用户名参数，那么服务端构建的SQL语句就如下：
```sql
select * from user where username='' or 1=1 #' and password='123456'
```
而#会忽略后面的语句，而1=1属于常等型条件，因此这个SQL将查询出所有的登录用户。其实上面的SQL注入只是在参数层面做了些手脚，如果是引入了一些功能性的SQL那就更危险了，比如上面的登录功能，如果用户名使用这个 `' or 1=1;delete * from users; #`，那么在";"之后相当于是另外一条新的SQL，这个SQL是删除全表，是非常危险的操作，因此SQL注入这种还是需要特别注意的。

如何解决SQL注入
* 严格的参数校验  
  参数校验就没得说了，在一些不该有特殊字符的参数中提前进行特殊字符校验即可。
* SQL预编译  
  在知道了SQL注入的原理之后，我们同样也了解到MySQL有预编译的功能，指的是在服务器启动时，MySQL Client把SQL语句的模板（变量采用占位符进行占位）发送给MySQL服务器，MySQL服务器对SQL语句的模板进行编译，编译之后根据语句的优化分析对相应的索引进行优化，在最终绑定参数时把相应的参数传送给MySQL服务器，直接进行执行，节省了SQL查询时间，以及MySQL服务器的资源，达到一次编译、多次执行的目的，除此之外，还可以防止SQL注入。  
  具体是怎样防止SQL注入的呢？实际上当将绑定的参数传到MySQL服务器，MySQL服务器对参数进行编译，即填充到相应的占位符的过程中，做了转义操作。我们常用的JDBC就有预编译功能，不仅提升性能，而且防止SQL注入。

# WHERE和HAVING有什么区别？
* WHERE是一个约束声明，使用WHERE约束来自数据库的数据，WHERE是在结果返回之前起作用的，WHERE中不能使用聚合函数。
* HAVING是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作，在HAVING中可以使用聚合函数。另一方面，HAVING子句中不能使用除了分组字段和聚合函数之外的其他字段。

从性能的角度来说，HAVING子句中如果使用了分组字段作为过滤条件，应该替换成WHERE子句。因为WHERE可以在执行分组操作和计算聚合函数之前过滤掉不需要的数据，性能会更好。  

# 数据库连接泄露
数据库连接泄露指的是如果在某次使用或者某段程序中没有正确地关闭Connection、Statement和ResultSet资源，那么每次执行都会留下一些没有关闭的连接，这些连接失去了引用而不能得到重新使用，因此就造成了数据库连接的泄漏。

# 脏读、幻读
* 脏读就是指当一个事务正在访问数据，并且对数据进行了修改，但是还没有来得及提交到数据库中，这时，另一个事务也访问这个数据，然后使用了这个数据
* 幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的数据行。

# DROP、TRUNCATE、DELETE的区别？
* drop 可以用来删除表或数据库并且将表所占用的空间全部释放。drop语句将删除表的结构被依赖的约束(constrain)、触发器(trigger), 依赖于该表的存储过程/函数将保留,但是变为 invalid 状态。
* truncate 会清除表数据并重置id从1开始；
* delete 就只删除记录；
* 速度上一般来说: drop> truncate > delete。使用上,想删除部分数据行用 delete，想删除表用 drop,想保留表而将所有数据删除，如果和事务无关，用truncate即可。如果和事务有关,或者想触发trigger,还是用delete。
* delete是DML语句,不会自动提交。drop/truncate都是DDL语句,执行后会自动提交。

# 数据库设计过程
* 范式与反范式的设计  
  * 范式设计的目的是为了减少数据冗余从而节约存储空间提高查询效率，同时也使得数据一致性容易得到维护。
  * 反范式的设计主要考录历史数据要反应历史问题。需要将数据冗余到表中。  

  设计数据库时一定要考虑范式和反范式设计。具体采用什么方式就要分析我们的业务是属于哪种情况视具体情况而定采用哪种方式。

* 扩展性设计  
项目初期业务场景数据模型是一对一，并且分析后期有可能会变成一对多。这种情况不要为了前期方便设计成一对一数据模型。这样做到后期可能得不尝失。这就是数据拓展性设计需要考虑。

* 数据库约束  
数据约束最好是在数据设计之初就定义好。包括非空约束数据唯一性约束。这样可以解决很多系统空异常，并且使得数据更好维护。  

* 数据库访问权限界定  
数据库访问权限一定要控制在自己的系统范围内，严禁其他系统直接操作数据库。系统需要与其他系统进行信息交换，或者数据变更，应该采用本系统开发接口给外部系统进行调用并且对接口调用进行日志记录，而不是直接开放数据库给对方。这么做主要是方便核查异常数据写入场景分析问题源。快速定位问题源。同时通过分析接口调用日志分析外部系统问题。

* 表字段最好考虑添加创建时间和修改时间  
这个设计主要是考虑到平时数据维护和数据分析用，不一定时业务上使用。如果某段时间业务出问题，可以通过数据的创建时间和修改时间来找到这部分异常数据。


# 数据库分页
使用 LIMIT N M。N表示偏移量，M表示返回的行数。  
在偏移量非常大的时候，例如 LIMIT 10000,20 这样的查询，这时MySQL需要查询10020条记录然后只返回最后20条，前面的10000条记录都将被抛弃，这样的代价是非常高的。要优化这种查询，要么是在页面中限制分页的数量，要么是优化大偏移量的性能。

​优化此类分页查询的一个最简单的办法就是尽可能地使用**索引覆盖**扫描。  
例如：  
* 原查询语句为：
```sql
select * from zb_articleceiresultperformance where pubday = '20210908' limit 1,10
```
耗时： 3.048801 sec
* 优化后：
```sql
SELECT
	* 
FROM
	zb_articleceiresultperformance main
	RIGHT JOIN ( SELECT id FROM zb_articleceiresultperformance WHERE pubday = '20210908' LIMIT 1, 10 ) temp_table ON main.id = temp_table.id
```
耗时：0.367586 sec

## 原理
因为回表查询（需要遍历两遍索引树，先通过普通索引定位到id，再通过聚集索引定位到行记录）性能较低

# inner Join 和 left join
* left join（左连接）获取左表的所有记录，右表没有对应匹配的记录则为NULL。  
![img](https://pic4.zhimg.com/80/v2-35125df03a8eb791aa1284473190b983_720w.webp)  
* right join（右连接）获取右表的所有记录，左表没有对应匹配的记录则为NULL。  
![img](https://pic4.zhimg.com/80/v2-b408aed0087e36af623f5b95d70055d7_720w.webp)  
* inner Join（等值连接,内连接）只返回两个表中联接字段相等的行。  
![img](https://pic2.zhimg.com/80/v2-ac4e75e16439e204179aca9f3e87b091_720w.webp)

# 存储过程(procedure)和函数(function)区别
* 标识符不同，函数标识符是function，存储过程是procedure。
* 函数返回单个值或者表对象，而过程没有返回值, 但是可以通过out参数返回多个值;
* 函数的参数只能是 IN 类型，存储过程的参数可以是 IN OUT INOUT 三种类型。
* 函数使用 select 调用，存储过程需要使用 call 调用。SQL语句不可调用存储过程。

# SQL各子句的执行顺序。
先有表（from、on、join），才能过滤（where），再才能分组（group、having），再才能选择去重（select distinct），再才能排序（order by），最后才能分页（limit）

总的顺序：from>join>where>group by>聚合函数>having>select>order by>limit


# MySQL 中有哪些常见日志
* 重做日志（redo log）：物理日志  
作用是确保事务的持久性。 redo 日志记录事务执行后的状态，用来恢复未写入 data file 的已提交事务数据。

* 回滚日志（undo log）：逻辑日志  
作用是保证数据的原子性。 保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。

* 二进制日志（binlog）：逻辑日志  
常用于主从同步或数据同步中，也可用于数据库基于时间点的还原。

* 错误日志（errorlog）  
记录着 MySQL 启动和停止，以及服务器在运行过程中发生的错误的相关信息。在默认情况下，系统记录错误日志的功能是关闭的，错误信息被输出到标准错误输出。

* 普通查询日志（general query log）  
记录了服务器接收到的每一个命令，无论命令语句是否正确，因此会带来不小开销，所以也是默认关闭的。

* 慢查询日志（slow query log）  
记录执行时间过长和没有使用索引的查询语句（默认 10s），同时只会记录执行成功的语句。

* 中继日志（relay log）  
在从节点中存储接收到的 binlog 日志内容，用于主从同步。


# MVCC
MVCC 的英文全称是 Multiversion Concurrency Control ，中文意思是多版本并发控制技术。原理是，通过数据行的多个版本管理来实现数据库的并发控制，简单来说就是保存数据的历史版本。可以通过比较版本号决定数据是否显示出来。读取数据的时候不需要加锁可以保证事务的隔离效果。

## MVCC 可以解决什么问题？
* 读写之间阻塞的问题，通过 MVCC 可以让读写互相不阻塞，读不相互阻塞，写不阻塞读，这样可以提升数据并发处理能力。
* 降低了死锁的概率，这个是因为 MVCC 采用了乐观锁的方式，读取数据时，不需要加锁，写操作，只需要锁定必要的行。
* 解决了一致性读的问题，当我们朝向某个数据库在时间点的快照是，只能看到这个时间点之前事务提交更新的结果，不能看到时间点之后事务提交的更新结果。